数据驱动

前提：
1.你一定得用过vue
2.如果没有使用过的 可以去官网看一看 使用教程

# Vue与模板
1.编写 页面模板
  1.直接在html标签中写 标签
  2.使用template
  3.使用单文件 （<template />）
2.创建vue的实例
  1.在Vue的构造函数中提供：data,methods,computed,watcher,props,...
3.将Vue挂载到页面中 （mount）  








# 数据驱动模型

Vue的执行流程
1.获得模板：模板中有“坑”
2.利用Vue构造函数中所提供的数据来“填坑”，得到可以在页面中显示的“标签”了
3.将标签替换页面中原来有坑的标签

Vue 利用 我们提供的数据 和 页面中 模板生成了一个新的html标签（node元素）
替换到了页面 中放置模板的位置







# 简单的模板渲染







# 虚拟DOM
# 目标：
1.怎么将真正的DOM转换为虚拟DOM
2.怎么将虚拟DOM转换为真正的DOM
思路与深拷贝类似

# 概念
1.柯里化：
  一个函数原本有多个参数，之传入**一个**参数，生成一个新函数，由新函数接收剩下的参数来运行得到的结构。
2.偏函数：一个函数原本有多个参数，之传入**一部分**参数，生成一个新函数，由新函数接收剩下的参数来运行得到的结构。
3.高阶函数：一个函数参数是个函数，该函数对参数这个函数进行加工，得到一个函数，这个加工用的函数就是高阶函数


# 为什么要使用柯里化？为了提升性能，使用柯里化可以缓存一部分能力
使用两个案例来说明
1.判断元素
2.虚拟DOM 的render方法

# 1.判断元素
Vue 本质上是使用HTML的字符串作为模板的，将字符串的模板转换为AST,再转换为VNode
- 模板 -> AST
- AST  -> VNode
- VNode -> DOM
哪个阶段最消耗性能？
最消耗性能的是字符串解析（ 模板->AST ）

例子：let s = "1 + 2 * ( 3 + 4 * (5 + 6)) "
写一个程序，解析之个表达式，得到结果(一般化)
我们一般会将这个表达式转换为"波兰式"表达式，然后使用栈结构来运算

在Vue中每个标签可以是真正的HTML标签，也可以是自定义的组件
在Vue源码中其实将所有可以用的HTML标签已经存起来了

# 假设这里只考虑几个标签

----js
let tags = 'div,p,a,img,ul,li'.split(',');
----

需要一个函数，判断一个标签名是否为内置的标签
----js
function isHTMLTag(tagName){
  tagName = tagName.toLowerCase();
  <!-- for(let i=0;i<tags.lenght;i++){
    if(tagName === tags[i]) return true;
  } -->
  if(tags.indexOf(tagName)>-1) return true;
  return false;
}
----

模板是任意编写的，可以写的很简单，也可以写的很复杂，indexOf内部也是要循环的
如果有6种内置标签，而模板中有10个标签需要判断，那么就需要执行60次循环

# 2.虚拟DOM的render方法

思考：vue项目**模板转换为抽象语法树**需要执行几次？
- 页面一开始加载需要渲染
- 每个属性（响应性）数据发生变化的时候要渲染
- watch,computed等等

我们昨天写的代码，每次需要渲染的时候，模板就会被解析一次（注意，这里我们简化了解析方法）


模板不变，AST就不会变，因为AST是模板生成的
render的作用是将虚拟DOM转换为真正的DOM加到页面中
- 虚拟DOM可以降级理解为AST
- 一个项目运行的时候，模板是不会变的，就表示AST是不会变的
我们可以将代码进行优化，将虚拟DOM缓存起来，然后生成一个函数，函数只需要传入数据就可以得到真正的DOM

# 凡是解析都会涉及到AST


# 问题
- 没明白柯里化怎么就只要循环一次。
  **缓存一部分行为**

- mountComponent 这个函数里面的内容，没太理解


makeMap (['div','p'])需要遍历这个数据 生成 键值对
---
最开始生成set的时候需要去遍历（只需要遍历一次）
let set = {
  div:true,
  p:true
}

做判断的时候是不需要去遍历的
set['div'] //true 内置标签
set['navigtor'] //!!undefined -> false
---

但是如果是使用的函数，每次都需要循环遍历判断是不是数组中的