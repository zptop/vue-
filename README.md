数据驱动

前提：
1.你一定得用过vue
2.如果没有使用过的 可以去官网看一看 使用教程

# Vue与模板
1.编写 页面模板
  1.直接在html标签中写 标签
  2.使用template
  3.使用单文件 （<template />）
2.创建vue的实例
  1.在Vue的构造函数中提供：data,methods,computed,watcher,props,...
3.将Vue挂载到页面中 （mount）  








# 数据驱动模型

Vue的执行流程
1.获得模板：模板中有“坑”
2.利用Vue构造函数中所提供的数据来“填坑”，得到可以在页面中显示的“标签”了
3.将标签替换页面中原来有坑的标签

Vue 利用 我们提供的数据 和 页面中 模板生成了一个新的html标签（node元素）
替换到了页面 中放置模板的位置







# 简单的模板渲染







# 虚拟DOM
# 目标：
1.怎么将真正的DOM转换为虚拟DOM
2.怎么将虚拟DOM转换为真正的DOM
思路与深拷贝类似

# 概念
1.柯里化：
  一个函数原本有多个参数，之传入**一个**参数，生成一个新函数，由新函数接收剩下的参数来运行得到的结构。
2.偏函数：一个函数原本有多个参数，之传入**一部分**参数，生成一个新函数，由新函数接收剩下的参数来运行得到的结构。
3.高阶函数：一个函数参数是个函数，该函数对参数这个函数进行加工，得到一个函数，这个加工用的函数就是高阶函数


# 为什么要使用柯里化？为了提升性能，使用柯里化可以缓存一部分能力
使用两个案例来说明
1.判断元素
2.虚拟DOM 的render方法

# 1.判断元素
Vue 本质上是使用HTML的字符串作为模板的，将字符串的模板转换为AST,再转换为VNode
- 模板 -> AST
- AST  -> VNode
- VNode -> DOM
哪个阶段最消耗性能？
最消耗性能的是字符串解析（ 模板->AST ）

例子：let s = "1 + 2 * ( 3 + 4 * (5 + 6)) "
写一个程序，解析之个表达式，得到结果(一般化)
我们一般会将这个表达式转换为"波兰式"表达式，然后使用栈结构来运算

在Vue中每个标签可以是真正的HTML标签，也可以是自定义的组件
在Vue源码中其实将所有可以用的HTML标签已经存起来了

# 假设这里只考虑几个标签

----js
let tags = 'div,p,a,img,ul,li'.split(',');
----

需要一个函数，判断一个标签名是否为内置的标签
----js
function isHTMLTag(tagName){
  tagName = tagName.toLowerCase();
  <!-- for(let i=0;i<tags.lenght;i++){
    if(tagName === tags[i]) return true;
  } -->
  if(tags.indexOf(tagName)>-1) return true;
  return false;
}
----

模板是任意编写的，可以写的很简单，也可以写的很复杂，indexOf内部也是要循环的
如果有6种内置标签，而模板中有10个标签需要判断，那么就需要执行60次循环

# 2.虚拟DOM的render方法

思考：vue项目**模板转换为抽象语法树**需要执行几次？
- 页面一开始加载需要渲染
- 每个属性（响应性）数据发生变化的时候要渲染
- watch,computed等等

我们昨天写的代码，每次需要渲染的时候，模板就会被解析一次（注意，这里我们简化了解析方法）


模板不变，AST就不会变，因为AST是模板生成的
render的作用是将虚拟DOM转换为真正的DOM加到页面中
- 虚拟DOM可以降级理解为AST
- 一个项目运行的时候，模板是不会变的，就表示AST是不会变的
我们可以将代码进行优化，将虚拟DOM缓存起来，然后生成一个函数，函数只需要传入数据就可以得到真正的DOM

# 凡是解析都会涉及到AST


# 问题
- 没明白柯里化怎么就只要循环一次。
  **缓存一部分行为**

- mountComponent 这个函数里面的内容，没太理解


makeMap (['div','p'])需要遍历这个数据 生成 键值对
---
最开始生成set的时候需要去遍历（只需要遍历一次）
let set = {
  div:true,
  p:true
}

做判断的时候是不需要去遍历的
set['div'] //true 内置标签
set['navigtor'] //!!undefined -> false
---

但是如果是使用的函数，每次都需要循环遍历判断是不是数组中的

# 响应式原理
- 我们在使用Vue的时候，赋值属性，获得属性都是直接使用的Vue实例
- 我们在设置属性值的时候，页面的数据更新

---js
Object.defineProperty(对象，'属性名',{
  writeable:
  configable:
  enumerable: 控制属性是否可枚举 for...in循环
  set(){}  赋值触发
  get(){}  取值触发
  value  用到get和set后，value就不用考虑了
})
---

# 实际开发中对象一般是有多级
---js
let o = {
  list:[
    {}
  ],
  ads:[
    {}
  ],
  user:{

  }
}
---
怎么处理呢？ 递归


对于对象可以使用递归来响应式化，但是数组我们也需要处理
-push
-pop
-shift
-unshift
-reverse
-sort
-splice

要做什么事情？
1.在改变数组数据的时候，要发出通知
  1.vue2中的缺陷，数组发生变化，设置length没法通知(vue3中使用Proxy语法，ES6的语法解决了这个问题)
2.加入的元素应该变成响应式的  

技巧：如果一个函数已经定义了，但是我们需要扩展其功能，我们一般的处理办法：
1.使用一个临时的函数名存储函数
2.重新定义原来的函数
3.定义扩展的功能
4.调用临时的那个函数

扩展数组的Push和pop怎么处理呢？
- 直接修改prototype **不行**
- 修改要进行响应式化的数组的原型(__proto__)


已经将对象改成响应式的了，如果直接给对象赋值另一个对象，那么就不是响应式的了，怎么办？


# 发布订阅模式
任务：
- 作业
- 代理方法(app.name,app._data.name)
- 事件模型(node:event模块)
-vue中observer与watcher和Dep


# 代理方法
就是要将app._data中的成员给映射到app上

由于需要在更新数据的时候，更新页面的内容
所以app._data访问的成员与app访问的成员应该是同一个成员

由于app._data已经是响应式的对象了，所以只需要让app访问的成员去访问app._data的对应成员就可以了。

例如：
```js
app.name 转换为 app._data.name
app.xxx 转换为 app._data.xxx
```

target相当于app
src相当于app._data
prop相当于name
引入了一个函数proxy( target, src , prop )，将target的操作给映射到src.prop上
这里是因为当时没有`proxy`语法(es6)